<!DOCTYPE html>
<!--
This file is part of Cockpit.

Copyright (C) 2015 Red Hat, Inc.

Cockpit is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

Cockpit is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Cockpit; If not, see <http://www.gnu.org/licenses/>.
-->
<html>
<head>
    <meta charset="utf-8">
    <title>Kube client tests</title>
    <link rel="stylesheet" href="../../../tools/qunit.css" type="text/css" media="screen" />
    <script type="text/javascript" src="../../../tools/qunit.js"></script>

    <script src="../../base1/angular.js"></script>
    <script src="../scripts/kube-client.js"></script>
    <script src="../scripts/kube-client-mock.js"></script>
    <script src="fixture-basic.js"></script>
    <script src="fixture-large.js"></script>
</head>
<body>
    <h1 id="qunit-header">Kube client tests</h1>
    <h2 id="qunit-banner"></h2>
    <div id="qunit-testrunner-toolbar"></div>
    <h2 id="qunit-userAgent"></h2>
    <ol id="qunit-tests"></ol>
    <div id="qunit-fixture">test markup, will be hidden</div>
    <div id="done-flag" style="display:none">Done</div>
<script>
(function() {
    "use strict";

    var module = angular.module("kubeClient.tests", [
        "kubeClient",
        "kubeClient.mock"
    ])

    module.config([
        'KubeWatchProvider',
        'KubeRequestProvider',
        function(KubeWatchProvider, KubeRequestProvider) {
            KubeWatchProvider.KubeWatchFactory = "MockKubeWatch";
            KubeRequestProvider.KubeRequestFactory = "MockKubeRequest";
        }
    ]);

    function kubeTest(name, count, fixtures, func) {
        console.log("registering test");
        module.run([
            "$injector",
            "MockKubeData",
            function($injector, data) {
                asyncTest(name, function() {
                    expect(count);
                    data.load(fixtures);
                    $injector.invoke(func);
                });
            }
        ]);
    }

    kubeTest("loader load", 4, fixture_basic, [
        "$q",
        "kubeLoader",
        function($q, loader) {
console.log("running");
            var promise = loader.load("nodes");
            ok(!!promise, "promise returned");
            equal(typeof promise.then, "promise has then");
            equal(typeof promise.catch, "promise has catch");
            equal(typeof promise.finally, "promise has finally");
console.log("starting");
            start();
        }
    ]);
/*
    kubeTest("loader watch", 6, fixture_basic, [
        "$q",
        "kubeLoader",
        "kubeSelect",
        function($q, loader, select) {
            loader.watch("nodes");
        }
    ]);

    kubeTest("list nodes", 6, fixture_basic, [
        "$q",
        "kubeLoader",
        "kubeSelect",
        function($q, loader, select) {
            $q.when(loader.watch("nodes"), function() {
                var nodes = select().kind("Node");
                ok("Node:f530580d-a169-11e4-8651-10c37bdb8410" in nodes, "found node");
                var node = nodes["Node:f530580d-a169-11e4-8651-10c37bdb8410"];
                equal(node.metadata.name, "127.0.0.1", "localhost node");
                equal(typeof node.spec.capacity, "object", "node has resources");

                / * Check basic key behavior * /
                equal(node.key, "Node:f530580d-a169-11e4-8651-10c37bdb8410", "key is set correctly");

                / * Key should not be encoded as JSON * /
                var parsed = JSON.parse(JSON.stringify(node));
                ok(!("key" in parsed), "key should not be serialized")
                strictEqual(parsed.key, undefined, "key not be undefined after serialize");

                select.reset(true);
                start();
            });
        }
    ]);

    asyncTest("list pods", function() {
        expect(3);

        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {
            var pods = client.select("Pod");
            equal(pods.items.length, 3, "number of pods");
            var pod = pods["Pod:11768037-ab8a-11e4-9a7c-080027300d85"];
            equal(typeof pod, "object", "found pod")
            equal(pod.metadata.labels.name, "apache", "pod has label");

            client.close();
            start();
        });
    });

    asyncTest("set namespace", function() {
        expect(4);
        var added = 0;
        var removed = 0;

        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {
            var pods = client.select("Pod");
            client.track(pods);
            equal(pods.items.length, 3, "number of pods");
            $(pods).on("removed", function(ev, item) {
                removed++;
                if (removed == 2) {
                    equal(pods.items.length, 1, "number of other pods");
                    var pod = pods["Pod:9f1a316f-4db6-11e5-971a-525400e58104"];
                    equal(typeof pod, "object", "found pod");
                    client.namespace(null);
                }
            });

            $(pods).on("added", function(ev, item) {
                if (removed == 2)
                    added++;

                if (added == 2) {
                    equal(pods.items.length, 3, "all pods back");
                    client.close();
                    start();
                }
            });
            client.namespace("other");
        });
    });

    asyncTest("add pod", function() {
        expect(7);

        var ready = false;
        var changed = false;

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.watches.pods.wait().always(function() {
            ready = true;

            equal(pods.items.length, 3, "number of pods");
            equal(pods["Pod:11768037-ab8a-11e4-9a7c-080027300d85"].metadata.labels.name, "apache", "pod has label");

            kube_update("namespaces/default/pods/aardvark", {
                "kind": "Pod",
                "metadata": {
                    "name": "aardvark",
                    "uid": "22768037-ab8a-11e4-9a7c-080027300d85",
                    "namespace": "default",
                    "labels": {
                        "name": "aardvark"
                    },
                },
                "spec": {
                    "volumes": null,
                    "containers": [ ],
                    "imagePullPolicy": "IfNotPresent"
                }
            });
        });

        $(pods).on("added", function(ev, item) {
            if (!ready)
                return;

            equal(pods.items.length, 4, "added a pod");
            equal(pods["Pod:22768037-ab8a-11e4-9a7c-080027300d85"].metadata.labels.name,
                  "aardvark", "new pod present in items");
            ok(item === pods["Pod:22768037-ab8a-11e4-9a7c-080027300d85"], "passed right argument");
            equal(changed, false, "changed not yet");
        });

        $(pods).on("changed", function() {
            if (!ready)
                return;
            changed = true;
            ok(true, "changed also fired");
            client.close();
            start();
        });
    });

    asyncTest("update pod", function() {
        expect(7);

        var ready = false;
        var changed = false;

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.watches.pods.wait().always(function() {
            ready = true;

            equal(pods.items.length, 3, "number of pods");
            equal(pods.items[1].metadata.labels.name, "apache", "pod has label");

            kube_update("namespaces/default/pods/apache", {
                "kind": "Pod",
                "metadata": {
                    "name": "apache",
                    "uid": "11768037-ab8a-11e4-9a7c-080027300d85",
                    "namespace": "default",
                    "labels": {
                        "name": "apachepooo"
                    },
                }
            });
        });

        $(pods).on("updated", function(ev, item) {
            if (!ready)
                return;

            equal(pods.items.length, 3, "updated, didn't add a pod");
            equal(pods.items[1].metadata.labels.name, "apachepooo", "pod name updated");
            ok(item === pods.items[1], "passed right argument");
            equal(changed, false, "changed not yet");
        });

        $(pods).on("changed", function() {
            if (!ready)
                return;
            changed = true;
            ok(true, "changed also fired");
            client.close();
            start();
        });
    });

    asyncTest("remove pod", function() {
        expect(7);

        var ready = false;
        var changed = false;

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.watches.pods.wait().always(function() {
            ready = true;

            equal(pods.items.length, 3, "number of pods");
            equal(pods.items[1].metadata.labels.name, "apache", "pod has label");

            kube_update("namespaces/default/pods/apache", null);
        });

        $(pods).on("removed", function(ev, item) {
            if (!ready)
                return;

            equal(pods.items.length, 2, "removed a pod");
            equal(pods.items[0].metadata.labels.name, "wordpressreplica", "right pod got removed");
            equal(item.metadata.labels.name, "apache", "passed right argument");
            equal(changed, false, "changed not yet");
        });

        $(pods).on("changed", function(ev, item) {
            if (!ready)
                return;
            changed = true;
            ok(true, "changed also fired");
            client.close();
            start();
        });
    });

    asyncTest("list services", function() {
        expect(3);

        var client = kubernetes.k8client();

        client.watches.services.wait().always(function() {
            var services = client.select("Service");
            var svc = services.items[0];
            equal(services.items.length, 2, "number of services");
            equal(svc.metadata.name, "kubernetes", "service id");
            equal(svc.spec.selector.component, "apiserver", "service has label");

            client.close();
            start();
        });
    });

    test("close immediate", function() {
        var client = kubernetes.k8client();
        deepEqual(client.objects, { }, "no objects yet");

        / * No error should be thrown on immediate close* /
        client.close();
    });

    var create_items = [
        {
            "kind": "Pod",
            "apiVersion": "v1",
            "metadata": {
                "name": "pod1",
                "uid": "d072fb85-f70e-11e4-b829-10c37bdb8410",
                "resourceVersion": "634203",
                "labels": {
                    "name": "pod1"
                    },
            },
            "spec": {
                "volumes": null,
                "containers": [{
                    "name": "database",
                    "image": "mysql",
                    "ports": [{ "containerPort": 3306, "protocol": "TCP" }],
                }],
                "nodeName": "127.0.0.1"
            }
        },{
            "kind": "Node",
            "apiVersion": "v1",
            "metadata": {
                "name": "node1",
                "uid": "6e51438e-d161-11e4-acbc-10c37bdb8410",
                "resourceVersion": "634539",
            },
            "spec": {
                "externalID": "172.2.3.1"
            }
        }
    ];

    asyncTest("create", function() {
        expect(6);

        var client = kubernetes.k8client();

        client.create(create_items, "namespace1")
            .done(function() {
                equal(kube_data["namespaces/namespace1/pods/pod1"].metadata.name, "pod1", "pod created");
                equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");
                equal(kube_data["namespaces/namespace1"].metadata.name, "namespace1", "namespace created");

                equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                      "pod1", "pod object");
                equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                      "node1", "node object");
            })
            .always(function() {
                equal(this.state(), "resolved", "succeeded");
                client.close();
                start();
            });
    });

    asyncTest("create namespace exists", function() {
        expect(7);

        var client = kubernetes.k8client();

        var namespace_item = {
            "apiVersion" : "v1",
            "kind" : "Namespace",
            "metadata" : { "name": "namespace1" }
        };

        client.create(namespace_item)
            .always(function() {
                    equal(this.state(), "resolved", "namespace succeeded");
                    equal(kube_data["namespaces/namespace1"].metadata.name, "namespace1", "namespace created");

                    client.create(create_items, "namespace1")
                        .done(function() {
                            equal(kube_data["namespaces/namespace1/pods/pod1"].metadata.name, "pod1",
                                  "pod created");
                            equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");

                            equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                                  "pod1", "pod object");
                            equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                                  "node1", "node object");
                        })
                        .always(function() {
                            equal(this.state(), "resolved", "succeeded");

                            client.close();
                            start();
                        });
            });
    });

    asyncTest("create namespace default", function() {
        expect(5);

        var client = kubernetes.k8client();

        client.create(create_items)
            .done(function() {
                equal(kube_data["namespaces/default/pods/pod1"].metadata.name, "pod1", "pod created");
                equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");

                equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                      "pod1", "pod object");
                equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                      "node1", "node object");
            })
            .always(function() {
                equal(this.state(), "resolved", "succeeded");

                client.close();
                start();
            });
    });

    asyncTest("create object exists", function() {
        expect(3);

        var client = kubernetes.k8client();

        var items = create_items.slice();
        items.push(items[0]);

        client.create(items, "namespace1")
            .fail(function(ex, response) {
                equal(ex.status, 409, "http already exists");
                equal(response.code, 409, "kubernetes already exists");
            })
            .always(function() {
                equal(this.state(), "rejected", "failed");

                client.close();
                start();
            });
    });

    var create_mixed = [
        {
            "kind": "Node", "apiVersion": "v1",
            "metadata": { "name": "node1", "uid": "f072fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test": "test" }
        }, {
            "kind": "Service", "apiVersion": "v1",
            "metadata": { "name": "service2", "uid": "eeeefb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test2": "test2" }
        }, {
            "kind": "ReplicationController", "apiVersion": "v1",
            "metadata": { "name": "replicooo", "uid": "1111fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test": "test" }
        }, {
            "kind": "Pod", "apiVersion": "v1",
            "metadata": { "name": "pod1", "uid": "d072fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "blah": "blah" }
        },{
            "kind": "Service", "apiVersion": "v1",
            "metadata": { "name": "service1", "uid": "e072fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test": "test" }
        }
    ];

    asyncTest("create sort", function() {
        expect(2);

        var client = kubernetes.k8client();

        client.watches.pods.wait().always(function() {
            var items = client.select();
            client.track(items);

            var added = [];
            var count = 0;

            $(items).on("added", function(ev, item) {
                added.push(item.kind);

                count += 1;
                if (count == 4) {
                    deepEqual(added, [ "Namespace", "Service", "Service", "Pod" ], "added right order");
                } else if (count == 6) {
                    client.close();
                    start();
                }
            });

            client.create(create_mixed, "namespace1")
                .always(function() {
                    equal(this.state(), "resolved", "succeeded");
                });
        });
    });

    asyncTest("delete pod", function() {
        expect(7);

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.create(create_items, "namespace2")
            .done(function() {
                equal(kube_data["namespaces/namespace2/pods/pod1"].metadata.name, "pod1", "pod created");
                equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");
                equal(kube_data["namespaces/namespace2"].metadata.name, "namespace2", "namespace created");

                equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                      "pod1", "pod object");
                equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                      "node1", "node object");

                client.remove("/api/v1/namespaces/namespace2/pods/pod1")
                    .done(function(){
                        client.watches.pods.wait().always(function() {
                            for (var i = pods.items.length - 1; i >= 0; i--) {
                                if(pods.items[i].metadata.labels.name === "pod1") {
                                    equal(pods.items[i].metadata.labels.name, "pod1", "right pod got removed");
                                    return;
                                }
                            };
                        });
                    });
            })
            .always(function() {
                equal(this.state(), "resolved", "succeeded");
                client.close();
                start();
            });
    });


    QUnit.module("large", {
        setup: function() {
            kube_data = $.extend(true, { }, mock_basic, mock_large);
        }
    });

    function has_unique_uids(items) {
        var i, seen = { };
        for (i = 0; i < items.items.length; i++) {
            if (seen[items.items[i].metadata.uid])
                return false;
            seen[items.items[i].metadata.uid] = items[i];
        }
        return true;
    }

    asyncTest("lookup", function() {
        var expected = {
            "apiVersion": "v1",
            "kind": "ReplicationController",
            "metadata": { "labels": { "example": "mock", "name": "3controller" },
                "name": "3controller",
                "resourceVersion": 10000,
                "uid": "11768037-ab8a-11e4-9a7c-100001001",
                "namespace": "default"
            },
            "selfLink": "/api/v1/namespaces/default/replicationcontrollers/3controller",
            "spec": { "replicas": 1, "selector": { "factor3": "yes" } }
        };

        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            / * Get the item * /
            var item = client.lookup("ReplicationController", "3controller", "default");
            deepEqual(item, expected, "correct item");

            / * The same item, without namespace * /
            item = client.lookup("ReplicationController", "3controller");
            deepEqual(item, expected, "selected without namespace");

            / * Any replication controller * /
            item = client.lookup("ReplicationController");
            equal(item.kind, "ReplicationController", "any replication controller");

            / * Shouldn't match * /
            item = client.lookup("BadKind", "3controller", "default");
            strictEqual(item, null, "mismatch kind");
            item = client.lookup("ReplicationController", "badcontroller", "default");
            strictEqual(item, null, "mismatch name");
            item = client.lookup("ReplicationController", "3controller", "baddefault");
            strictEqual(item, null, "mismatch namespace");

            client.close();
            start();
        });
    });


    asyncTest("select", function() {
        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            / * Select everything odd, 500 pods * /
            var results = client.select(null, "default", { "type": "odd" });
            equal(results.items.length, 500, "correct amount");
            ok(has_unique_uids(results), "unique objects");

            / * Select everything odd, but wrong namespace, no pods * /
            var results = client.select(null, "other", { "type": "odd" });
            equal(results.items.length, 0, "other namespace no pods");

            / * The same ones selected even when a second (present) label * /
            results = client.select(null, "default", { "type": "odd", "tag": "silly"  });
            equal(results.items.length, 500, "with additional label");
            ok(has_unique_uids(results), "unique objects with additional label");

            / * Nothing selected when additional invalid field * /
            results = client.select(null, "default", { "type": "odd", "tag": "billy"  });
            equal(results.items.length, 0, "no objects");

            / * Limit by kind * /
            var results = client.select("Pod", "default", { "type": "odd" });
            equal(results.items.length, 500, "by kind");
            ok(has_unique_uids(results), "unique objects by kind");

            / * Limit by invalid kind * /
            var results = client.select("Ood", "default", { "type": "odd" });
            equal(results.items.length, 0, "nothing for invalid kind");

            / * Everything selected when no selector * /
            results = client.select(null, "default");
            equal(results.items.length, 1006, "all objects");

            / * Everything selected when no selector * /
            results = client.select("Pod", "default", null);
            equal(results.items.length, 1002, "all pods");

            / * Nothing selected when bad namespace * /
            results = client.select(null, "bad");
            equal(results.items.length, 0, "bad namespace no objects");

            / * Get the node when a null namespace * /
            results = client.select(null, null);
            equal(results.items.length, 1008, "without namespace");

            / * Get the node when a null namespace * /
            results = client.select(null, null);
            equal(results.items.length, 1008, "without namespace");

            / * Nothing selected when empty selector * /
            results = client.select(null, "default", { });
            equal(results.items.length, 0, "namespace objects");

            client.close();
            start();
        });
    });

    asyncTest("infer", function() {
        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            / * Start simple, exactly the labels selector matches * /
            var results = client.infer(null, "default", { "tag": "silly", "type": "odd" });
            equal(results.items.length, 1, "selected replication controller");
            equal(results.items[0].metadata.name, "oddcontroller", "got oddcontroller");

            / * Other namespace, no match * /
            var results = client.infer(null, "other", { "tag": "silly", "type": "odd" });
            equal(results.items.length, 0, "selected no controller");

            / * Now with extra labels, as you'd usually see it * /
            results = client.infer(null, "default", { "tag": "silly", "type": "odd", "another": "value" });
            equal(results.items.length, 1, "selected controller with extra labels");
            equal(results.items[0].metadata.name, "oddcontroller", "got oddcontroller with extra labels");

            / * Make two replication controllers match * /
            results = client.infer(null, "default", { "tag":"silly", "type":"odd", "another":"value", "factor3":"yes" });
            equal(results.items.length, 2, "two replication controllers");
            equal(results.items[0].metadata.name, "oddcontroller", "got oddcontroller in set");
            equal(results.items[1].metadata.name, "3controller", "got 3controller in set");

            / * Everything inferred when no labels * /
            results = client.infer(null, "default", null);
            equal(results.items.length, 4, "all objects with selectors");

            / * Everything inferred when no labels * /
            results = client.infer("ReplicationController", "default");
            equal(results.items.length, 2, "all replication controllers with selectors");

            / * Nothing when wrong namespace * /
            results = client.infer(null, "other");
            equal(results.items.length, 0, "no objects with other namespace");

            / * Nothing inferred when empty label * /
            results = client.infer(null, "default", { });
            equal(results.items.length, 0, "no objects");

            client.close();
            start();
        });
    });

    asyncTest("hosting", function() {
        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            / * Find out which pods this node is hosting * /
            var results = client.hosting("Pod", "127.0.0.1");
            equal(results.items.length, 1, "selected hosted pods");
            equal(results.items[0].metadata.name, "wordpress", "got wordpress pod");

            client.close();
            start();
        });
    });



    asyncTest("list images", function() {
        expect(3);

        var client = kubernetes.k8client();
        equal(client.watches.images, undefined, "no image watcher");
        client.include("images");
        notEqual(client.watches.images, undefined, "watcher created");
        client.watches.images.wait().always(function() {
            var images = client.select("Image");
            equal(images.items.length, 0, "number of images");
            client.close();
            start();
        });
    });

    asyncTest("list imagestreams", function() {
        expect(3);

        var client = kubernetes.k8client();
        client.include("imagestreams");
        client.watches.imagestreams.wait().always(function() {
            var streams = client.select("ImageStream");
            equal(streams.items.length, 1, "number of imagestreams");
            var stream = streams["ImageStream:c216455b-4cc5-11e5-8a7f-0e5582eacc27"];
            equal(typeof stream, "object", "found imagestream")
            equal(stream.metadata.name, "mock-image-stream", "imagestream name");
            client.close();
            start();
        });
    });
    */

    angular.module('exceptionOverride', []).factory('$exceptionHandler', function() {
        return function(exception, cause) {
            exception.message += ' (caused by "' + cause + '")';
            throw exception;
        };
    });

    module.run(function() {
        QUnit.start();
    });

    angular.bootstrap(document, ['kubeClient.tests']);
}());
</script>
</body>
</html>
